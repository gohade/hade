{
  "version": 3,
  "sources": ["../../../../node_modules/ts-dedent/src/index.ts", "../../../../node_modules/mermaid/src/mermaid.ts"],
  "sourcesContent": ["export function dedent(\n  templ: TemplateStringsArray | string,\n  ...values: unknown[]\n): string {\n  let strings = Array.from(typeof templ === 'string' ? [templ] : templ);\n\n  // 1. Remove trailing whitespace.\n  strings[strings.length - 1] = strings[strings.length - 1].replace(\n    /\\r?\\n([\\t ]*)$/,\n    '',\n  );\n\n  // 2. Find all line breaks to determine the highest common indentation level.\n  const indentLengths = strings.reduce((arr, str) => {\n    const matches = str.match(/\\n([\\t ]+|(?!\\s).)/g);\n    if (matches) {\n      return arr.concat(\n        matches.map((match) => match.match(/[\\t ]/g)?.length ?? 0),\n      );\n    }\n    return arr;\n  }, <number[]>[]);\n\n  // 3. Remove the common indentation from all strings.\n  if (indentLengths.length) {\n    const pattern = new RegExp(`\\n[\\t ]{${Math.min(...indentLengths)}}`, 'g');\n\n    strings = strings.map((str) => str.replace(pattern, '\\n'));\n  }\n\n  // 4. Remove leading whitespace.\n  strings[0] = strings[0].replace(/^\\r?\\n/, '');\n\n  // 5. Perform interpolation.\n  let string = strings[0];\n\n  values.forEach((value, i) => {\n    // 5.1 Read current indentation level\n    const endentations = string.match(/(?:^|\\n)( *)$/)\n    const endentation = endentations ? endentations[1] : ''\n    let indentedValue = value\n    // 5.2 Add indentation to values with multiline strings\n    if (typeof value === 'string' && value.includes('\\n')) {\n      indentedValue = String(value)\n        .split('\\n')\n        .map((str, i) => {\n          return i === 0 ? str : `${endentation}${str}`\n        })\n        .join('\\n');\n    }\n\n    string += indentedValue + strings[i + 1];\n  });\n\n  return string;\n}\n\nexport default dedent;\n", "/**\n * Web page integration module for the mermaid framework. It uses the mermaidAPI for mermaid\n * functionality and to render the diagrams to svg code!\n */\nimport dedent from 'ts-dedent';\nimport { MermaidConfig } from './config.type';\nimport { log } from './logger';\nimport utils from './utils';\nimport { mermaidAPI, ParseOptions, RenderResult } from './mermaidAPI';\nimport { registerLazyLoadedDiagrams, loadRegisteredDiagrams } from './diagram-api/detectType';\nimport type { ParseErrorFunction } from './Diagram';\nimport { isDetailedError } from './utils';\nimport type { DetailedError } from './utils';\nimport { ExternalDiagramDefinition } from './diagram-api/types';\nimport { UnknownDiagramError } from './errors';\n\nexport type {\n  MermaidConfig,\n  DetailedError,\n  ExternalDiagramDefinition,\n  ParseErrorFunction,\n  RenderResult,\n  ParseOptions,\n  UnknownDiagramError,\n};\n\nexport interface RunOptions {\n  /**\n   * The query selector to use when finding elements to render. Default: `\".mermaid\"`.\n   */\n  querySelector?: string;\n  /**\n   * The nodes to render. If this is set, `querySelector` will be ignored.\n   */\n  nodes?: ArrayLike<HTMLElement>;\n  /**\n   * A callback to call after each diagram is rendered.\n   */\n  postRenderCallback?: (id: string) => unknown;\n  /**\n   * If `true`, errors will be logged to the console, but not thrown. Default: `false`\n   */\n  suppressErrors?: boolean;\n}\n\nconst handleError = (error: unknown, errors: DetailedError[], parseError?: ParseErrorFunction) => {\n  log.warn(error);\n  if (isDetailedError(error)) {\n    // handle case where error string and hash were\n    // wrapped in object like`const error = { str, hash };`\n    if (parseError) {\n      parseError(error.str, error.hash);\n    }\n    errors.push({ ...error, message: error.str, error });\n  } else {\n    // assume it is just error string and pass it on\n    if (parseError) {\n      parseError(error);\n    }\n    if (error instanceof Error) {\n      errors.push({\n        str: error.message,\n        message: error.message,\n        hash: error.name,\n        error,\n      });\n    }\n  }\n};\n\n/**\n * ## run\n *\n * Function that goes through the document to find the chart definitions in there and render them.\n *\n * The function tags the processed attributes with the attribute data-processed and ignores found\n * elements with the attribute already set. This way the init function can be triggered several\n * times.\n *\n * ```mermaid\n * graph LR;\n *  a(Find elements)-->b{Processed}\n *  b-->|Yes|c(Leave element)\n *  b-->|No |d(Transform)\n * ```\n *\n * Renders the mermaid diagrams\n *\n * @param options - Optional runtime configs\n */\nconst run = async function (\n  options: RunOptions = {\n    querySelector: '.mermaid',\n  }\n) {\n  try {\n    await runThrowsErrors(options);\n  } catch (e) {\n    if (isDetailedError(e)) {\n      log.error(e.str);\n    }\n    if (mermaid.parseError) {\n      mermaid.parseError(e as string);\n    }\n    if (!options.suppressErrors) {\n      log.error('Use the suppressErrors option to suppress these errors');\n      throw e;\n    }\n  }\n};\n\nconst runThrowsErrors = async function (\n  { postRenderCallback, querySelector, nodes }: Omit<RunOptions, 'suppressErrors'> = {\n    querySelector: '.mermaid',\n  }\n) {\n  const conf = mermaidAPI.getConfig();\n\n  log.debug(`${!postRenderCallback ? 'No ' : ''}Callback function found`);\n\n  let nodesToProcess: ArrayLike<HTMLElement>;\n  if (nodes) {\n    nodesToProcess = nodes;\n  } else if (querySelector) {\n    nodesToProcess = document.querySelectorAll(querySelector);\n  } else {\n    throw new Error('Nodes and querySelector are both undefined');\n  }\n\n  log.debug(`Found ${nodesToProcess.length} diagrams`);\n  if (conf?.startOnLoad !== undefined) {\n    log.debug('Start On Load: ' + conf?.startOnLoad);\n    mermaidAPI.updateSiteConfig({ startOnLoad: conf?.startOnLoad });\n  }\n\n  // generate the id of the diagram\n  const idGenerator = new utils.initIdGenerator(conf.deterministicIds, conf.deterministicIDSeed);\n\n  let txt: string;\n  const errors: DetailedError[] = [];\n\n  // element is the current div with mermaid class\n  // eslint-disable-next-line unicorn/prefer-spread\n  for (const element of Array.from(nodesToProcess)) {\n    log.info('Rendering diagram: ' + element.id);\n    /*! Check if previously processed */\n    if (element.getAttribute('data-processed')) {\n      continue;\n    }\n    element.setAttribute('data-processed', 'true');\n\n    const id = `mermaid-${idGenerator.next()}`;\n\n    // Fetch the graph definition including tags\n    txt = element.innerHTML;\n\n    // transforms the html to pure text\n    txt = dedent(utils.entityDecode(txt)) // removes indentation, required for YAML parsing\n      .trim()\n      .replace(/<br\\s*\\/?>/gi, '<br/>');\n\n    const init = utils.detectInit(txt);\n    if (init) {\n      log.debug('Detected early reinit: ', init);\n    }\n    try {\n      const { svg, bindFunctions } = await render(id, txt, element);\n      element.innerHTML = svg;\n      if (postRenderCallback) {\n        await postRenderCallback(id);\n      }\n      if (bindFunctions) {\n        bindFunctions(element);\n      }\n    } catch (error) {\n      handleError(error, errors, mermaid.parseError);\n    }\n  }\n  if (errors.length > 0) {\n    // TODO: We should be throwing an error object.\n    throw errors[0];\n  }\n};\n\n/**\n * Used to set configurations for mermaid.\n * This function should be called before the run function.\n * @param config - Configuration object for mermaid.\n */\n\nconst initialize = function (config: MermaidConfig) {\n  mermaidAPI.initialize(config);\n};\n\n/**\n * ## init\n *\n * @deprecated Use {@link initialize} and {@link run} instead.\n *\n * Renders the mermaid diagrams\n *\n * @param config - **Deprecated**, please set configuration in {@link initialize}.\n * @param nodes - **Default**: `.mermaid`. One of the following:\n * - A DOM Node\n * - An array of DOM nodes (as would come from a jQuery selector)\n * - A W3C selector, a la `.mermaid`\n * @param callback - Called once for each rendered diagram's id.\n */\nconst init = async function (\n  config?: MermaidConfig,\n  nodes?: string | HTMLElement | NodeListOf<HTMLElement>,\n  callback?: (id: string) => unknown\n) {\n  log.warn('mermaid.init is deprecated. Please use run instead.');\n  if (config) {\n    initialize(config);\n  }\n  const runOptions: RunOptions = { postRenderCallback: callback, querySelector: '.mermaid' };\n  if (typeof nodes === 'string') {\n    runOptions.querySelector = nodes;\n  } else if (nodes) {\n    if (nodes instanceof HTMLElement) {\n      runOptions.nodes = [nodes];\n    } else {\n      runOptions.nodes = nodes;\n    }\n  }\n  await run(runOptions);\n};\n\n/**\n * Used to register external diagram types.\n * @param diagrams - Array of {@link ExternalDiagramDefinition}.\n * @param opts - If opts.lazyLoad is false, the diagrams will be loaded immediately.\n */\nconst registerExternalDiagrams = async (\n  diagrams: ExternalDiagramDefinition[],\n  {\n    lazyLoad = true,\n  }: {\n    lazyLoad?: boolean;\n  } = {}\n) => {\n  registerLazyLoadedDiagrams(...diagrams);\n  if (lazyLoad === false) {\n    await loadRegisteredDiagrams();\n  }\n};\n\n/**\n * ##contentLoaded Callback function that is called when page is loaded. This functions fetches\n * configuration for mermaid rendering and calls init for rendering the mermaid diagrams on the\n * page.\n */\nconst contentLoaded = function () {\n  if (mermaid.startOnLoad) {\n    const { startOnLoad } = mermaidAPI.getConfig();\n    if (startOnLoad) {\n      mermaid.run().catch((err) => log.error('Mermaid failed to initialize', err));\n    }\n  }\n};\n\nif (typeof document !== 'undefined') {\n  /*!\n   * Wait for document loaded before starting the execution\n   */\n  window.addEventListener('load', contentLoaded, false);\n}\n\n/**\n * ## setParseErrorHandler  Alternative to directly setting parseError using:\n *\n * ```js\n * mermaid.parseError = function(err,hash){=\n *   forExampleDisplayErrorInGui(err);  // do something with the error\n * };\n * ```\n *\n * This is provided for environments where the mermaid object can't directly have a new member added\n * to it (eg. dart interop wrapper). (Initially there is no parseError member of mermaid).\n *\n * @param parseErrorHandler - New parseError() callback.\n */\nconst setParseErrorHandler = function (parseErrorHandler: (err: any, hash: any) => void) {\n  mermaid.parseError = parseErrorHandler;\n};\n\nconst executionQueue: (() => Promise<unknown>)[] = [];\nlet executionQueueRunning = false;\nconst executeQueue = async () => {\n  if (executionQueueRunning) {\n    return;\n  }\n  executionQueueRunning = true;\n  while (executionQueue.length > 0) {\n    const f = executionQueue.shift();\n    if (f) {\n      try {\n        await f();\n      } catch (e) {\n        log.error('Error executing queue', e);\n      }\n    }\n  }\n  executionQueueRunning = false;\n};\n\n/**\n * Parse the text and validate the syntax.\n * @param text - The mermaid diagram definition.\n * @param parseOptions - Options for parsing.\n * @returns true if the diagram is valid, false otherwise if parseOptions.suppressErrors is true.\n * @throws Error if the diagram is invalid and parseOptions.suppressErrors is false.\n */\nconst parse = async (text: string, parseOptions?: ParseOptions): Promise<boolean | void> => {\n  return new Promise((resolve, reject) => {\n    // This promise will resolve when the render call is done.\n    // It will be queued first and will be executed when it is first in line\n    const performCall = () =>\n      new Promise((res, rej) => {\n        mermaidAPI.parse(text, parseOptions).then(\n          (r) => {\n            // This resolves for the promise for the queue handling\n            res(r);\n            // This fulfills the promise sent to the value back to the original caller\n            resolve(r);\n          },\n          (e) => {\n            log.error('Error parsing', e);\n            mermaid.parseError?.(e);\n            rej(e);\n            reject(e);\n          }\n        );\n      });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\n\n/**\n * Function that renders an svg with a graph from a chart definition. Usage example below.\n *\n * ```javascript\n *  element = document.querySelector('#graphDiv');\n *  const graphDefinition = 'graph TB\\na-->b';\n *  const { svg, bindFunctions } = await mermaid.render('graphDiv', graphDefinition);\n *  element.innerHTML = svg;\n *  bindFunctions?.(element);\n * ```\n *\n * @remarks\n * Multiple calls to this function will be enqueued to run serially.\n *\n * @param id - The id for the SVG element (the element to be rendered)\n * @param text - The text for the graph definition\n * @param container - HTML element where the svg will be inserted. (Is usually element with the .mermaid class)\n *   If no svgContainingElement is provided then the SVG element will be appended to the body.\n *    Selector to element in which a div with the graph temporarily will be\n *   inserted. If one is provided a hidden div will be inserted in the body of the page instead. The\n *   element will be removed when rendering is completed.\n * @returns Returns the SVG Definition and BindFunctions.\n */\nconst render = (id: string, text: string, container?: Element): Promise<RenderResult> => {\n  return new Promise((resolve, reject) => {\n    // This promise will resolve when the mermaidAPI.render call is done.\n    // It will be queued first and will be executed when it is first in line\n    const performCall = () =>\n      new Promise((res, rej) => {\n        mermaidAPI.render(id, text, container).then(\n          (r) => {\n            // This resolves for the promise for the queue handling\n            res(r);\n            // This fulfills the promise sent to the value back to the original caller\n            resolve(r);\n          },\n          (e) => {\n            log.error('Error parsing', e);\n            mermaid.parseError?.(e);\n            rej(e);\n            reject(e);\n          }\n        );\n      });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\n\nconst mermaid: {\n  startOnLoad: boolean;\n  parseError?: ParseErrorFunction;\n  mermaidAPI: typeof mermaidAPI;\n  parse: typeof parse;\n  render: typeof render;\n  init: typeof init;\n  run: typeof run;\n  registerExternalDiagrams: typeof registerExternalDiagrams;\n  initialize: typeof initialize;\n  contentLoaded: typeof contentLoaded;\n  setParseErrorHandler: typeof setParseErrorHandler;\n} = {\n  startOnLoad: true,\n  mermaidAPI,\n  parse,\n  render,\n  init,\n  run,\n  registerExternalDiagrams,\n  initialize,\n  parseError: undefined,\n  contentLoaded,\n  setParseErrorHandler,\n};\n\nexport default mermaid;\n"],
  "mappings": "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",
  "names": ["i", "init"]
}
